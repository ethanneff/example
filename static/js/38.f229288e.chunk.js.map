{"version":3,"sources":["apps/Playground/FortuneWheel/utils.tsx","apps/Playground/FortuneWheel/Wheel.tsx","apps/Playground/FortuneWheel/index.tsx"],"names":["getNewLocation","minSpin","maxSpin","numOfSegments","location","min","max","Math","floor","random","getRandomRange","Wheel","memo","size","Dimensions","get","width","backgroundColor","textColor","fontSize","segments","noBounce","padAngle","innerRadius","spinSpeed","bounceSpeed","onComplete","color","useColor","dropShadow","useDropShadow","background","text","radius","knobSize","knobOffset","length","angleOfSegment","angleOffset","spinning","useRef","angle","Animated","Value","yPosition","arcs","d3","map","arc","index","instance","outerRadius","path","centroid","segment","onSpinComplete","useCallback","current","winnerIndex","deg","getWinnerIndex","spin","newLocation","timing","toValue","duration","easing","Easing","inOut","sin","useNativeDriver","start","onPress","bounce","config","useEffect","TouchableOpacity","View","style","transform","translateY","interpolate","inputRange","outputRange","height","borderRadius","alignItems","marginTop","position","fill","light","points","stroke","secondary","strokeWidth","rotate","x","y","i","key","d","String","origin","rotation","textAnchor","display","useMemo","value","primary","info","danger","brand","warning","success","useSegments","nav","useNav","useState","winner","setWinner","a","navBack","onLeftPress","title","center"],"mappings":"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","file":"static/js/38.f229288e.chunk.js","sourcesContent":["type GetRandomRange = {\n  min: number;\n  max: number;\n};\n\nconst getRandomRange = ({min, max}: GetRandomRange) => {\n  return Math.floor(Math.random() * (max - min) + min);\n};\n\ntype GetNewLocation = {\n  minSpin: number;\n  maxSpin: number;\n  numOfSegments: number;\n  location: number;\n};\n\nexport const getNewLocation = ({\n  minSpin,\n  maxSpin,\n  numOfSegments,\n  location,\n}: GetNewLocation) => {\n  const spins = getRandomRange({min: minSpin, max: maxSpin}) * 360;\n  const winner = Math.floor(Math.random() * numOfSegments);\n  const winnerSection = (winner * 360) / numOfSegments;\n  const newLocation = location + spins + winnerSection;\n  return newLocation;\n};\n\ntype GetWinnerIndex = {\n  location: number;\n  numOfSegments: number;\n  angleOfSegment: number;\n};\n\nexport const getWinnerIndex = ({\n  location,\n  numOfSegments,\n  angleOfSegment,\n}: GetWinnerIndex) => {\n  const deg = 360 - Math.floor(location % 360);\n  const index = Math.floor(deg / angleOfSegment);\n  return index >= numOfSegments ? 0 : index;\n};\n","import React, {memo, useCallback, useEffect, useRef} from 'react';\nimport {Animated, Dimensions, Easing, TouchableOpacity} from 'react-native';\nimport * as d3 from 'd3-shape';\nimport Svg, {G, Path, Polygon, Text} from 'react-native-svg';\nimport {useColor, useDropShadow} from '../../../hooks';\nimport {getNewLocation, getWinnerIndex} from './utils';\n\ntype Segment = {\n  value: string;\n  display: string;\n  color: string;\n};\n\ntype Props = {\n  size?: number;\n  padAngle?: number;\n  backgroundColor?: string;\n  borderColor?: string;\n  textColor?: string;\n  borderWidth?: number;\n  fontSize?: number;\n  innerRadius?: number;\n  segments: Segment[];\n  spinSpeed?: number;\n  noBounce?: boolean;\n  bounceSpeed?: number;\n  minSpin?: number;\n  maxSpin?: number;\n  onComplete: (segment: Segment) => void;\n};\n\nexport const Wheel = memo(\n  ({\n    size = Dimensions.get('screen').width,\n    backgroundColor,\n    textColor,\n    fontSize = 24,\n    segments,\n    noBounce,\n    padAngle = 0.02,\n    innerRadius = 60,\n    spinSpeed = 1000,\n    bounceSpeed = 5000,\n    minSpin = 3,\n    maxSpin = 7,\n    onComplete,\n  }: Props) => {\n    const color = useColor();\n    const dropShadow = useDropShadow();\n    const background = backgroundColor || color.background;\n    const text = textColor || color.text;\n    const radius = size / 2;\n    const knobSize = size / 8;\n    const knobOffset = knobSize * 0.6;\n    const numOfSegments = segments.length;\n    const angleOfSegment = 360 / numOfSegments;\n    const angleOffset = angleOfSegment / 2;\n    const spinning = useRef(false);\n    const location = useRef(0);\n    const angle = new Animated.Value(0);\n    const yPosition = new Animated.Value(-1);\n    const arcs = d3\n      .pie()(segments.map(() => 1))\n      .map((arc: any, index) => {\n        const instance = d3\n          .arc()\n          .padAngle(padAngle)\n          .outerRadius(radius)\n          .innerRadius(innerRadius);\n        return {\n          path: instance(arc),\n          centroid: instance.centroid(arc),\n          segment: segments[index],\n        };\n      });\n\n    const onSpinComplete = useCallback(() => {\n      spinning.current = false;\n      const winnerIndex = getWinnerIndex({\n        location: location.current,\n        numOfSegments,\n        angleOfSegment,\n      });\n      onComplete(segments[winnerIndex]);\n    }, [angleOfSegment, numOfSegments, onComplete, segments]);\n\n    const spin = useCallback(() => {\n      const newLocation = getNewLocation({\n        minSpin,\n        maxSpin,\n        numOfSegments,\n        location: location.current,\n      });\n      location.current = newLocation;\n      spinning.current = true;\n      Animated.timing(angle, {\n        toValue: newLocation,\n        duration: spinSpeed,\n        easing: Easing.inOut(Easing.sin),\n        useNativeDriver: true,\n      }).start(onSpinComplete);\n    }, [angle, maxSpin, minSpin, numOfSegments, onSpinComplete, spinSpeed]);\n\n    const onPress = useCallback(() => {\n      if (spinning.current) {\n        return;\n      }\n      spin();\n    }, [spin]);\n\n    const bounce = useCallback(\n      (toValue: number) => {\n        const config = {toValue, duration: bounceSpeed, useNativeDriver: true};\n        Animated.timing(yPosition, config).start(() =>\n          bounce(toValue === 1 ? -1 : 1),\n        );\n      },\n      [bounceSpeed, yPosition],\n    );\n\n    useEffect(() => {\n      if (noBounce) {\n        return;\n      }\n      bounce(1);\n    }, [bounce, noBounce]);\n\n    return (\n      <TouchableOpacity onPress={onPress}>\n        <Animated.View\n          style={{\n            transform: [\n              {\n                translateY: yPosition.interpolate({\n                  inputRange: [-1, 0, 1],\n                  outputRange: [-10, 0, -10],\n                }),\n              },\n            ],\n            backgroundColor: background,\n            width: size,\n            height: size,\n            borderRadius: size,\n            alignItems: 'center',\n            marginTop: knobOffset,\n            ...dropShadow(3),\n          }}>\n          <Svg\n            style={{\n              marginTop: -knobOffset,\n              position: 'absolute',\n              width: knobSize,\n              height: knobSize,\n              ...dropShadow(6),\n            }}>\n            <Polygon\n              fill={color.light}\n              points={`${knobSize / 2},0 ${knobSize * 0.85},${knobSize / 3} ${\n                knobSize / 2\n              },${knobSize} ${knobSize * 0.15},${knobSize / 3},`}\n              stroke={color.secondary}\n              strokeWidth={0.2}\n            />\n          </Svg>\n          <Animated.View\n            style={{\n              width: size,\n              height: size,\n              transform: [\n                {\n                  rotate: angle.interpolate({\n                    inputRange: [-360, 0, 360],\n                    outputRange: ['-360deg', '0deg', '360deg'],\n                  }),\n                },\n              ],\n            }}>\n            <Svg\n              style={{\n                transform: [{rotate: `-${angleOffset}deg`}],\n              }}>\n              <G x={radius} y={radius}>\n                {arcs.map((arc, i) => (\n                  <G key={`arc-${i}`}>\n                    <Path d={String(arc.path)} fill={arc.segment.color} />\n                    <G\n                      origin={`${arc.centroid}`}\n                      rotation={(i * 360) / segments.length + angleOffset}>\n                      <Text\n                        fill={text}\n                        fontSize={fontSize}\n                        textAnchor=\"middle\"\n                        x={arc.centroid[0]}\n                        y={arc.centroid[1] - knobOffset / 2}>\n                        {arc.segment.display}\n                      </Text>\n                    </G>\n                  </G>\n                ))}\n              </G>\n            </Svg>\n          </Animated.View>\n        </Animated.View>\n      </TouchableOpacity>\n    );\n  },\n);\n","import React, {memo, useCallback, useMemo, useState} from 'react';\nimport {Screen, Text} from '../../../components';\nimport {useColor, useNav} from '../../../hooks';\nimport {Wheel} from './Wheel';\n\nconst useSegments = () => {\n  const color = useColor();\n  return useMemo(\n    () => [\n      {display: '1', value: '1', color: color.primary},\n      {display: '2', value: '2', color: color.info},\n      {display: '3', value: '3', color: color.danger},\n      {display: '4', value: '4', color: color.brand},\n      {display: '5', value: '5', color: color.warning},\n      {display: '6', value: '6', color: color.success},\n      {display: '7', value: '7', color: color.secondary},\n    ],\n    [\n      color.brand,\n      color.danger,\n      color.info,\n      color.primary,\n      color.secondary,\n      color.success,\n      color.warning,\n    ],\n  );\n};\n\nexport default memo(function PlaygroundFortuneWheel() {\n  const segments = useSegments();\n  const nav = useNav();\n  const [winner, setWinner] = useState(null);\n\n  const onComplete = useCallback((a) => {\n    setWinner(a.display);\n  }, []);\n\n  const navBack = useCallback(nav('playground'), [nav]);\n\n  // TODO: fix text on android\n  // TODO: increase duration based on spin\n\n  return (\n    <Screen onLeftPress={navBack} title=\"FortuneWheel\">\n      <Wheel onComplete={onComplete} segments={segments} />\n      <Text center title={String(winner)} />\n    </Screen>\n  );\n});\n"],"sourceRoot":""}