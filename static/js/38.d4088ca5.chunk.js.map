{"version":3,"sources":["apps/Playground/FortuneWheel/utils.tsx","apps/Playground/FortuneWheel/Wheel.tsx","apps/Playground/FortuneWheel/index.tsx"],"names":["getNewLocation","minSpin","maxSpin","numOfSegments","location","min","max","Math","floor","random","getRandomRange","Wheel","memo","size","Dimensions","get","width","backgroundColor","textColor","fontSize","segments","noBounce","padAngle","innerRadius","spinSpeed","bounceSpeed","onComplete","color","useColor","dropShadow","useDropShadow","radius","knobSize","knobOffset","length","angleOfSegment","angleOffset","spinning","useRef","angle","Animated","Value","yPosition","arcs","d3","map","arc","index","instance","outerRadius","path","centroid","segment","onSpinComplete","useCallback","current","winnerIndex","deg","getWinnerIndex","spin","newLocation","timing","toValue","duration","easing","Easing","inOut","sin","useNativeDriver","start","onPress","bounce","config","useEffect","TouchableOpacity","View","style","transform","translateY","interpolate","inputRange","outputRange","height","borderRadius","alignItems","marginTop","position","fill","light","points","stroke","dark","strokeWidth","rotate","x","y","i","key","d","String","origin","rotation","textAnchor","display","useMemo","value","primary","info","danger","brand","warning","success","secondary","useSegments","nav","useNav","useState","winner","setWinner","a","onLeftPress","to","title","center"],"mappings":"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","file":"static/js/38.d4088ca5.chunk.js","sourcesContent":["type GetRandomRange = {\n  min: number;\n  max: number;\n};\n\nconst getRandomRange = ({min, max}: GetRandomRange) => {\n  return Math.floor(Math.random() * (max - min) + min);\n};\n\ntype GetNewLocation = {\n  minSpin: number;\n  maxSpin: number;\n  numOfSegments: number;\n  location: number;\n};\n\nexport const getNewLocation = ({\n  minSpin,\n  maxSpin,\n  numOfSegments,\n  location,\n}: GetNewLocation) => {\n  const spins = getRandomRange({min: minSpin, max: maxSpin}) * 360;\n  const winner = Math.floor(Math.random() * numOfSegments);\n  const winnerSection = (winner * 360) / numOfSegments;\n  const newLocation = location + spins + winnerSection;\n  return newLocation;\n};\n\ntype GetWinnerIndex = {\n  location: number;\n  numOfSegments: number;\n  angleOfSegment: number;\n};\n\nexport const getWinnerIndex = ({\n  location,\n  numOfSegments,\n  angleOfSegment,\n}: GetWinnerIndex) => {\n  const deg = 360 - Math.floor(location % 360);\n  const index = Math.floor(deg / angleOfSegment);\n  return index >= numOfSegments ? 0 : index;\n};\n","import React, {memo, useCallback, useEffect, useRef} from 'react';\nimport {Animated, Dimensions, Easing, TouchableOpacity} from 'react-native';\nimport * as d3 from 'd3-shape';\nimport Svg, {G, Path, Polygon, Text} from 'react-native-svg';\nimport {useColor, useDropShadow} from '../../../hooks';\nimport {getNewLocation, getWinnerIndex} from './utils';\n\ntype Segment = {\n  value: string;\n  display: string;\n  color: string;\n};\n\ntype Props = {\n  size?: number;\n  padAngle?: number;\n  backgroundColor?: string;\n  borderColor?: string;\n  textColor?: string;\n  borderWidth?: number;\n  fontSize?: number;\n  innerRadius?: number;\n  segments: Segment[];\n  spinSpeed?: number;\n  noBounce?: boolean;\n  bounceSpeed?: number;\n  minSpin?: number;\n  maxSpin?: number;\n  onComplete: (segment: Segment) => void;\n};\n\nexport const Wheel = memo(\n  ({\n    size = Dimensions.get('screen').width,\n    backgroundColor = 'lightgrey',\n    textColor = 'white',\n    fontSize = 24,\n    segments,\n    noBounce,\n    padAngle = 0.02,\n    innerRadius = 60,\n    spinSpeed = 1000,\n    bounceSpeed = 5000,\n    minSpin = 1,\n    maxSpin = 3,\n    onComplete,\n  }: Props) => {\n    const color = useColor();\n    const dropShadow = useDropShadow(5);\n    const radius = size / 2;\n    const knobSize = size / 8;\n    const knobOffset = knobSize * 0.6;\n    const numOfSegments = segments.length;\n    const angleOfSegment = 360 / numOfSegments;\n    const angleOffset = angleOfSegment / 2;\n    const spinning = useRef(false);\n    const location = useRef(0);\n    const angle = new Animated.Value(0);\n    const yPosition = new Animated.Value(-1);\n    const arcs = d3\n      .pie()(segments.map(() => 1))\n      .map((arc: any, index) => {\n        const instance = d3\n          .arc()\n          .padAngle(padAngle)\n          .outerRadius(radius)\n          .innerRadius(innerRadius);\n        return {\n          path: instance(arc),\n          centroid: instance.centroid(arc),\n          segment: segments[index],\n        };\n      });\n\n    const onSpinComplete = useCallback(() => {\n      spinning.current = false;\n      const winnerIndex = getWinnerIndex({\n        location: location.current,\n        numOfSegments,\n        angleOfSegment,\n      });\n      onComplete(segments[winnerIndex]);\n    }, [angleOfSegment, numOfSegments, onComplete, segments]);\n\n    const spin = useCallback(() => {\n      const newLocation = getNewLocation({\n        minSpin,\n        maxSpin,\n        numOfSegments,\n        location: location.current,\n      });\n      location.current = newLocation;\n      spinning.current = true;\n      Animated.timing(angle, {\n        toValue: newLocation,\n        duration: spinSpeed,\n        easing: Easing.inOut(Easing.sin),\n        useNativeDriver: true,\n      }).start(onSpinComplete);\n    }, [angle, maxSpin, minSpin, numOfSegments, onSpinComplete, spinSpeed]);\n\n    const onPress = useCallback(() => {\n      if (spinning.current) {\n        return;\n      }\n      spin();\n    }, [spin]);\n\n    const bounce = useCallback(\n      (toValue: number) => {\n        const config = {toValue, duration: bounceSpeed, useNativeDriver: true};\n        Animated.timing(yPosition, config).start(() =>\n          bounce(toValue === 1 ? -1 : 1),\n        );\n      },\n      [bounceSpeed, yPosition],\n    );\n\n    useEffect(() => {\n      if (noBounce) {\n        return;\n      }\n      bounce(1);\n    }, [bounce, noBounce]);\n\n    return (\n      <TouchableOpacity onPress={onPress}>\n        <Animated.View\n          style={{\n            transform: [\n              {\n                translateY: yPosition.interpolate({\n                  inputRange: [-1, 0, 1],\n                  outputRange: ['-10', '0', '-10'],\n                }),\n              },\n            ],\n            backgroundColor,\n            width: size,\n            height: size,\n            borderRadius: size,\n            alignItems: 'center',\n            marginTop: knobOffset,\n            ...dropShadow,\n          }}>\n          <Svg\n            style={{\n              marginTop: -knobOffset,\n              position: 'absolute',\n              width: knobSize,\n              height: knobSize,\n              ...dropShadow,\n            }}>\n            <Polygon\n              fill={color.light}\n              points={`${knobSize / 2},0 ${knobSize * 0.85},${knobSize / 3} ${\n                knobSize / 2\n              },${knobSize} ${knobSize * 0.15},${knobSize / 3},`}\n              stroke={color.dark}\n              strokeWidth={1}\n            />\n          </Svg>\n          <Animated.View\n            style={{\n              width: size,\n              height: size,\n              transform: [\n                {\n                  rotate: angle.interpolate({\n                    inputRange: [-360, 0, 360],\n                    outputRange: ['-360deg', '0deg', '360deg'],\n                  }),\n                },\n              ],\n            }}>\n            <Svg\n              style={{\n                transform: [{rotate: `-${angleOffset}deg`}],\n              }}>\n              <G x={radius} y={radius}>\n                {arcs.map((arc, i) => (\n                  <G key={`arc-${i}`}>\n                    <Path d={String(arc.path)} fill={arc.segment.color} />\n                    <G\n                      origin={`${arc.centroid}`}\n                      rotation={(i * 360) / segments.length + angleOffset}>\n                      <Text\n                        fill={textColor}\n                        fontSize={fontSize}\n                        textAnchor=\"middle\"\n                        x={arc.centroid[0]}\n                        y={arc.centroid[1] - knobOffset}>\n                        {arc.segment.display}\n                      </Text>\n                    </G>\n                  </G>\n                ))}\n              </G>\n            </Svg>\n          </Animated.View>\n        </Animated.View>\n      </TouchableOpacity>\n    );\n  },\n);\n","import React, {memo, useCallback, useMemo, useState} from 'react';\nimport {Screen, Text} from '../../../components';\nimport {useColor, useNav} from '../../../hooks';\nimport {Wheel} from './Wheel';\n\nconst useSegments = () => {\n  const color = useColor();\n  return useMemo(\n    () => [\n      {display: '1', value: '1', color: color.primary},\n      {display: '2', value: '2', color: color.info},\n      {display: '3', value: '3', color: color.danger},\n      {display: '4', value: '4', color: color.brand},\n      {display: '5', value: '5', color: color.warning},\n      {display: '6', value: '6', color: color.success},\n      {display: '7', value: '7', color: color.dark},\n      {display: '8', value: '8', color: color.secondary},\n    ],\n    [\n      color.brand,\n      color.danger,\n      color.dark,\n      color.info,\n      color.primary,\n      color.secondary,\n      color.success,\n      color.warning,\n    ],\n  );\n};\n\nexport default memo(function PlaygroundFortuneWheel() {\n  const segments = useSegments();\n  const nav = useNav();\n  const [winner, setWinner] = useState(null);\n\n  const onComplete = useCallback((a) => {\n    setWinner(a.display);\n  }, []);\n\n  // TODO: add animation decay\n  return (\n    <Screen onLeftPress={nav.to('playground')} title=\"FortuneWheel\">\n      <Wheel onComplete={onComplete} segments={segments} />\n      <Text center title={String(winner)} />\n    </Screen>\n  );\n});\n"],"sourceRoot":""}